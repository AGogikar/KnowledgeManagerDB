# KnowledgeManagerDB
The primary objective is to develop a C++ library that connects the llama.cpp embedding generator with a FAISS-based vector database. This library will allow for efficient storage and retrieval of significant files in a database, and support retrieval-augmented generation using the LLM (Large Language Models).

<<<<<<< HEAD

=======
>>>>>>> 67bb105d00d5b1cda8eb26907c360b4769b48503
Customer Documentation

Project Overview and Objectives
Objective:
The core aim of this project is to augment the capabilities of an existing Flutter application by seamlessly integrating the FAISS vector database with the llama.cpp embedding generator. 
Goals:
1) Develop a resilient C++ library that seamlessly bridges llama.cpp with FAISS.
2) Enable the streamlined storage, retrieval, and manipulation of vector data within the Flutter application.
3) Harness the embedding generation capabilities of llama.cpp and leverage FAISS for robust vector search functionalities.
4) Deliver a fully operational library merged with the Flutter application codebase.
Anticipated Outcomes:
1) A functional library seamlessly integrated into the Flutter application.
2) Improved performance in data handling, particularly in searching and retrieving large sets of vector data.
3) Enhanced user experience through faster and more accurate data processing

llama.cpp:
llama.cpp, a LLM library, is enlisted to generate embeddings, specifically tailored for natural language processing tasks. In the context of this project, llama.cpp will generat vector embeddings of the data, which will be seamlessly integrated into the C++ library.

Integration in the Project
C++ Library:
Serves as the nerve center, facilitating the integration of llama.cpp and FAISS.
Manages the fluid flow of data, ensuring a smooth processing and management of vector embeddings.
llama.cpp Embedding Generator:
Tasked with generating vector embeddings from input data, seamlessly integrated within the C++ library.
FAISS Vector Database:
Responsible for the management and indexing of vector embeddings generated by llama.cpp.
Optimized for efficient storage, search, and retrieval of large-scale data.

System Architecture Design

Components:

C++ Library:
Main aim is to facilitate the integration between llama.cpp and FAISS.
llama.cpp Embedding Generator:
Generates embeddings from input data.
Integrated within the C++ library.

FAISS Vector Database:
Manages and indexes embeddings, optimized for large-scale data.
Workflow:
1) Initiated with data input to llama.cpp for embedding generation.
2) Generated embeddings are then stored and indexed in FAISS.
3) Capitalizes on the robust capabilities of FAISS for efficient similarity searches and data retrieval.

Diagram Explaining the workflow
Step 1:    f() //C++ library 
             
Step 2:  Input (buffer variable) //input is the vector embeddings generated by llama.cpp
          
Step 3:      FAISS (storing embeddings using Vector databases)
          
Step 4: Top 3 results( index searching)
          
Step 5: Retrieved Text
       
Step 6: Text Output


Development Strategy

Setting Up FAISS and llama.cpp:

Installation of FAISS and llama.cpp.
Generating Embeddings with llama.cpp:
Application of llama.cpp to generate embeddings from input data.
Example:
 EmbeddingGenerator generator; 
vector<float> embedding = generator.generate(input_data);

Integrating with FAISS:

Storage of generated embeddings in a FAISS index.
Example: 
int d = embedding.size();   //Dimension of vectors
faiss::IndexFlatL2 index(d);
 index.add(1, embedding.data()); //Adding single vector

Retrieval-Augmented Generation:

Implementation of a function to query similar embeddings based on new inputs.
Retrieval and utilization of these embeddings to augment the generation process.
Example: 
int k=10// no. of nearest neighbours, long l[k], long D[k];
index.search(1, new_embedding.data(), k, D, I); 
Using I(indices of nearest neighbours) for augmentation


Code Snippet to show the working of the library

#include <faiss/IndexFlat.h>  //C++ Library

class VectorDB {
private:
    faiss::Index *index;
    int d; // dimension of vectors

public:
    VectorDB(const std::string &db_path) {
        // Load or initialize the index here
        // For example, using a flat index (L2 distance)
        d = ...; // Set the dimension
        index = new faiss::IndexFlatL2(d);
        // If db_path exists, load the index
    }

    ~VectorDB() {
        delete index;
    }

    void add(std::vector<std::vector<float>> &vectors) {
        // Add vectors to the index
        index->add(vectors.size(), vectors[0].data());
    }

    std::vector<int> query(std::vector<float> &query_vector, int k) {
        // Perform a search for the k nearest neighbors
        std::vector<int> labels(k);
        std::vector<float> distances(k);
        index->search(1, query_vector.data(), k, distances.data(), labels.data());
        return labels;
    }
};

VectorDB db("Local_vector_db.db");
<<<<<<< HEAD



=======
>>>>>>> 67bb105d00d5b1cda8eb26907c360b4769b48503
